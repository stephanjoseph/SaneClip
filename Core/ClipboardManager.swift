import SwiftUI
import AppKit
import os.log
import Combine

@MainActor
@Observable
class ClipboardManager {
    var history: [ClipboardItem] = []
    var pinnedItems: [ClipboardItem] = []
    private var lastChangeCount: Int = 0
    private var lastClipboardContent: String?
    private var lastCopyTime: Date?
    private var timer: Timer?
    private var maxHistorySize: Int { SettingsModel.shared.maxHistorySize }
    private let logger = Logger(subsystem: "com.saneclip.app", category: "ClipboardManager")

    // Security: Types to ignore
    private let ignoredTypes: [NSPasteboard.PasteboardType] = [
        NSPasteboard.PasteboardType("org.nspasteboard.TransientType"),
        NSPasteboard.PasteboardType("org.nspasteboard.ConcealedType"),
        NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType")
    ]
    
    // Security: Bundle IDs to ignore (password managers)
    private let ignoredBundleIDs: Set<String> = [
        "com.agilebits.onepassword",
        "com.dashlane.dashlane",
        "com.lastpass.lastpass", 
        "com.wsigenesis.1Password7"
    ]

    init() {
        lastChangeCount = NSPasteboard.general.changeCount
        startMonitoring()
        loadHistory()
    }

    private func startMonitoring() {
        timer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
            Task { @MainActor in
                self?.checkClipboard()
            }
        }
    }

    private func checkClipboard() {
        let pasteboard = NSPasteboard.general
        guard pasteboard.changeCount != lastChangeCount else { return }
        lastChangeCount = pasteboard.changeCount

        // 1. Security Check: Transient Data
        // If the pasteboard contains "Transient" or "Concealed" types, DO NOT SAVE.
        // This is the standard way password managers signal "don't save this".
        if let types = pasteboard.types {
            for ignored in ignoredTypes {
                if types.contains(ignored) {
                    logger.debug("Ignored transient/concealed clipboard content")
                    return
                }
            }
        }

        // 2. Get source app info
        let frontmostApp = NSWorkspace.shared.frontmostApplication
        let sourceAppBundleID = frontmostApp?.bundleIdentifier
        let sourceAppName = frontmostApp?.localizedName

        // 3. Security Check: Excluded Apps (Settings & Hardcoded Password Managers)
        if let bundleID = sourceAppBundleID {
            // Check user-defined exclusions
            if SettingsModel.shared.isAppExcluded(bundleID) {
                logger.debug("Skipping clipboard from excluded app: \(sourceAppName ?? "unknown")")
                return
            }
            
            // Check hardcoded password managers if "Protect passwords" is on
            if SettingsModel.shared.protectPasswords && ignoredBundleIDs.contains(bundleID) {
                 logger.debug("Skipping clipboard from known password manager: \(bundleID)")
                 return
            }
        }

        // 4. Fallback Security: Timing-based (heuristic)
        // If "Protect passwords" is on, check if this copy happened too quickly after the previous one
        // (This handles cases where a password manager might clear the clipboard and restore it)
        // Note: The previous implementation logic was confusing. 
        // We will stick to the standard: If it's transient, we caught it above.
        // If it's from a password manager, we caught it above.
        // The "quick clear" logic is flaky. We'll simplify:
        // If we copied something < 0.5s ago, it might be a double-copy or automated script.
        // But let's trust the types and bundle IDs primarily.
        
        // 5. Get Content
        if let string = pasteboard.string(forType: .string), !string.isEmpty {
            lastClipboardContent = string
            lastCopyTime = Date()
            addItem(ClipboardItem(
                content: .text(string),
                sourceAppBundleID: sourceAppBundleID,
                sourceAppName: sourceAppName
            ))
        } else if let image = NSImage(pasteboard: pasteboard) {
            lastClipboardContent = nil
            lastCopyTime = nil
            addItem(ClipboardItem(
                content: .image(image),
                sourceAppBundleID: sourceAppBundleID,
                sourceAppName: sourceAppName
            ))
        } else {
            // Clipboard was cleared
            lastClipboardContent = nil
            lastCopyTime = nil
        }
    }

    private func addItem(_ item: ClipboardItem) {
        // Don't add duplicates at the top
        if let first = history.first, first.contentHash == item.contentHash {
            return
        }

        // Remove existing duplicate if present
        history.removeAll { $0.contentHash == item.contentHash }

        // Add to front
        history.insert(item, at: 0)

        // Trim to max size
        if history.count > maxHistorySize {
            history = Array(history.prefix(maxHistorySize))
        }

        saveHistory()
        logger.debug("Added clipboard item, history count: \(self.history.count)")
    }

    func paste(item: ClipboardItem) {
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()

        switch item.content {
        case .text(let string):
            pasteboard.setString(string, forType: .string)
        case .image(let image):
            if let tiffData = image.tiffRepresentation {
                pasteboard.setData(tiffData, forType: .tiff)
            }
        }

        // Move to front and increment paste count
        if let index = history.firstIndex(where: { $0.id == item.id }) {
            var updatedItem = history.remove(at: index)
            updatedItem.pasteCount += 1
            history.insert(updatedItem, at: 0)
            saveHistory()
        }

        // Play a subtle sound (if enabled)
        if SettingsModel.shared.playSounds {
            NSSound(named: .init("Pop"))?.play()
        }

        // Simulate Cmd+V with longer delay to let popover close
        Task { @MainActor in
            try? await Task.sleep(for: .milliseconds(200))
            self.simulatePaste()
        }
    }

    func pasteAsPlainText() {
        let pasteboard = NSPasteboard.general
        if let string = pasteboard.string(forType: .string) {
            pasteboard.clearContents()
            pasteboard.setString(string, forType: .string)
            simulatePaste()
        }
    }

    private func simulatePaste() {
        let source = CGEventSource(stateID: .hidSystemState)

        let keyDown = CGEvent(keyboardEventSource: source, virtualKey: 0x09, keyDown: true) // V key
        keyDown?.flags = .maskCommand

        let keyUp = CGEvent(keyboardEventSource: source, virtualKey: 0x09, keyDown: false)
        keyUp?.flags = .maskCommand

        keyDown?.post(tap: .cghidEventTap)
        keyUp?.post(tap: .cghidEventTap)
    }

    func delete(item: ClipboardItem) {
        history.removeAll { $0.id == item.id }
        pinnedItems.removeAll { $0.id == item.id }
        saveHistory()
    }

    func clearHistory() {
        history.removeAll()
        saveHistory()
    }

    func pasteItemAt(index: Int) {
        guard index < history.count else { return }
        paste(item: history[index])
    }

    func togglePin(item: ClipboardItem) {
        if pinnedItems.contains(where: { $0.id == item.id }) {
            pinnedItems.removeAll { $0.id == item.id }
        } else {
            pinnedItems.insert(item, at: 0)
        }
        saveHistory()
    }

    func isPinned(_ item: ClipboardItem) -> Bool {
        pinnedItems.contains { $0.id == item.id }
    }

    // MARK: - Persistence

    private var historyFileURL: URL {
        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let appFolder = appSupport.appendingPathComponent("SaneClip", isDirectory: true)
        try? FileManager.default.createDirectory(at: appFolder, withIntermediateDirectories: true)
        return appFolder.appendingPathComponent("history.json")
    }

    private func saveHistory() {
        // Only save text items (images are too large)
        let textItems = history.compactMap { item -> SavedClipboardItem? in
            if case .text(let string) = item.content {
                return SavedClipboardItem(
                    id: item.id,
                    text: string,
                    timestamp: item.timestamp,
                    sourceAppBundleID: item.sourceAppBundleID,
                    sourceAppName: item.sourceAppName,
                    pasteCount: item.pasteCount
                )
            }
            return nil
        }

        do {
            let data = try JSONEncoder().encode(textItems)
            // TODO: Encryption could be added here
            try data.write(to: historyFileURL, options: [.atomic, .completeFileProtection])
        } catch {
            logger.error("Failed to save history: \(error.localizedDescription)")
        }
    }

    private func loadHistory() {
        guard FileManager.default.fileExists(atPath: historyFileURL.path) else { return }

        do {
            let data = try Data(contentsOf: historyFileURL)
            let items = try JSONDecoder().decode([SavedClipboardItem].self, from: data)
            history = items.map {
                ClipboardItem(
                    id: $0.id,
                    content: .text($0.text),
                    timestamp: $0.timestamp,
                    sourceAppBundleID: $0.sourceAppBundleID,
                    sourceAppName: $0.sourceAppName,
                    pasteCount: $0.pasteCount
                )
            }
        } catch {
            logger.error("Failed to load history: \(error.localizedDescription)")
        }
    }
}
