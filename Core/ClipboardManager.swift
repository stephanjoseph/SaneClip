import SwiftUI
import AppKit
import os.log
import Combine

@MainActor
@Observable
class ClipboardManager {
    static var shared: ClipboardManager!

    var history: [ClipboardItem] = []
    var pinnedItems: [ClipboardItem] = []
    var pasteStack: [ClipboardItem] = []
    var isPasteStackMode: Bool { !pasteStack.isEmpty }
    private var lastChangeCount: Int = 0
    private var lastClipboardContent: String?
    private var lastCopyTime: Date?
    nonisolated(unsafe) private var timer: Timer?
    private var maxHistorySize: Int { SettingsModel.shared.maxHistorySize }
    private let logger = Logger(subsystem: "com.saneclip.app", category: "ClipboardManager")

    // Security: Types to ignore
    private let ignoredTypes: [NSPasteboard.PasteboardType] = [
        NSPasteboard.PasteboardType("org.nspasteboard.TransientType"),
        NSPasteboard.PasteboardType("org.nspasteboard.ConcealedType"),
        NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType")
    ]

    // Security: Bundle IDs to ignore (password managers)
    private let ignoredBundleIDs: Set<String> = [
        "com.agilebits.onepassword",
        "com.dashlane.dashlane",
        "com.lastpass.lastpass",
        "com.wsigenesis.1Password7"
    ]

    init() {
        lastChangeCount = NSPasteboard.general.changeCount
        startMonitoring()
        loadHistory()
    }

    deinit {
        timer?.invalidate()
        timer = nil
    }

    private func startMonitoring() {
        timer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
            Task { @MainActor in
                self?.checkClipboard()
            }
        }
    }

    private func checkClipboard() {
        // Cleanup expired items periodically
        cleanupExpiredItems()

        let pasteboard = NSPasteboard.general
        guard pasteboard.changeCount != lastChangeCount else { return }
        lastChangeCount = pasteboard.changeCount

        // Security checks
        guard !containsTransientTypes(pasteboard) else { return }

        let frontmostApp = NSWorkspace.shared.frontmostApplication
        let sourceAppBundleID = frontmostApp?.bundleIdentifier
        let sourceAppName = frontmostApp?.localizedName

        guard !isExcludedApp(bundleID: sourceAppBundleID, name: sourceAppName) else { return }

        // Process content
        processClipboardContent(pasteboard, sourceAppBundleID: sourceAppBundleID, sourceAppName: sourceAppName)
    }

    private func containsTransientTypes(_ pasteboard: NSPasteboard) -> Bool {
        guard let types = pasteboard.types else { return false }
        for ignored in ignoredTypes where types.contains(ignored) {
            logger.debug("Ignored transient/concealed clipboard content")
            return true
        }
        return false
    }

    private func cleanupExpiredItems() {
        let expireHours = SettingsModel.shared.autoExpireHours
        guard expireHours > 0 else { return }

        let cutoff = Date().addingTimeInterval(-Double(expireHours * 3600))
        let beforeCount = history.count

        // Remove expired items, but preserve pinned items
        history.removeAll { item in
            !isPinned(item) && item.timestamp < cutoff
        }

        if history.count < beforeCount {
            saveHistory()
            logger.debug("Cleaned up \(beforeCount - self.history.count) expired items")
        }
    }

    private func isExcludedApp(bundleID: String?, name: String?) -> Bool {
        guard let bundleID = bundleID else { return false }

        if SettingsModel.shared.isAppExcluded(bundleID) {
            logger.debug("Skipping clipboard from excluded app: \(name ?? "unknown")")
            return true
        }

        if SettingsModel.shared.protectPasswords && ignoredBundleIDs.contains(bundleID) {
            logger.debug("Skipping clipboard from known password manager: \(bundleID)")
            return true
        }

        return false
    }

    private func processClipboardContent(
        _ pasteboard: NSPasteboard, sourceAppBundleID: String?, sourceAppName: String?
    ) {
        if let string = pasteboard.string(forType: .string), !string.isEmpty {
            let processedString = processString(string)
            lastClipboardContent = processedString
            lastCopyTime = Date()
            addItem(ClipboardItem(
                content: .text(processedString),
                sourceAppBundleID: sourceAppBundleID,
                sourceAppName: sourceAppName
            ))
        } else if let image = NSImage(pasteboard: pasteboard) {
            lastClipboardContent = nil
            lastCopyTime = nil
            addItem(ClipboardItem(
                content: .image(image),
                sourceAppBundleID: sourceAppBundleID,
                sourceAppName: sourceAppName
            ))
        } else {
            lastClipboardContent = nil
            lastCopyTime = nil
        }
    }

    private func processString(_ string: String) -> String {
        let processed = ClipboardRulesManager.shared.process(string)
        if processed != string {
            logger.debug("Applied clipboard rules to content")
        }
        return processed
    }

    private func addItem(_ item: ClipboardItem) {
        // Don't add duplicates at the top
        if let first = history.first, first.contentHash == item.contentHash {
            return
        }

        // Remove existing duplicate if present
        history.removeAll { $0.contentHash == item.contentHash }

        // Add to front
        history.insert(item, at: 0)

        // Trim to max size
        if history.count > maxHistorySize {
            history = Array(history.prefix(maxHistorySize))
        }

        saveHistory()
        logger.debug("Added clipboard item, history count: \(self.history.count)")
    }

    func paste(item: ClipboardItem) {
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()

        switch item.content {
        case .text(let string):
            pasteboard.setString(string, forType: .string)
        case .image(let image):
            if let tiffData = image.tiffRepresentation {
                pasteboard.setData(tiffData, forType: .tiff)
            }
        }

        // Move to front and increment paste count
        if let index = history.firstIndex(where: { $0.id == item.id }) {
            var updatedItem = history.remove(at: index)
            updatedItem.pasteCount += 1
            history.insert(updatedItem, at: 0)
            saveHistory()
        }

        // Play a subtle sound (if enabled)
        if SettingsModel.shared.playSounds {
            NSSound(named: .init("Pop"))?.play()
        }

        // Simulate Cmd+V with longer delay to let popover close
        Task { @MainActor in
            try? await Task.sleep(for: .milliseconds(200))
            self.simulatePaste()
        }
    }

    /// Paste most recent item as plain text (for global shortcut)
    func pasteAsPlainText() {
        guard let item = history.first else { return }
        pasteAsPlainText(item: item)
    }

    /// Paste item as plain text (strips formatting)
    func pasteAsPlainText(item: ClipboardItem) {
        guard case .text(let string) = item.content else { return }

        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(string, forType: .string)

        // Move to front and increment paste count
        if let index = history.firstIndex(where: { $0.id == item.id }) {
            var updatedItem = history.remove(at: index)
            updatedItem.pasteCount += 1
            history.insert(updatedItem, at: 0)
            saveHistory()
        }

        if SettingsModel.shared.playSounds {
            NSSound(named: .init("Pop"))?.play()
        }

        Task { @MainActor in
            try? await Task.sleep(for: .milliseconds(200))
            self.simulatePaste()
        }
    }

    /// Paste item with a text transformation applied
    func pasteWithTransform(item: ClipboardItem, transform: TextTransform) {
        guard case .text(let string) = item.content else { return }

        let transformed = transform.apply(to: string)
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(transformed, forType: .string)

        // Move to front and increment paste count
        if let index = history.firstIndex(where: { $0.id == item.id }) {
            var updatedItem = history.remove(at: index)
            updatedItem.pasteCount += 1
            history.insert(updatedItem, at: 0)
            saveHistory()
        }

        if SettingsModel.shared.playSounds {
            NSSound(named: .init("Pop"))?.play()
        }

        Task { @MainActor in
            try? await Task.sleep(for: .milliseconds(200))
            self.simulatePaste()
        }
    }

    // MARK: - Paste Stack

    /// Add an item to the paste stack (FIFO queue)
    func addToPasteStack(_ item: ClipboardItem) {
        pasteStack.append(item)
        if SettingsModel.shared.playSounds {
            NSSound(named: .init("Pop"))?.play()
        }
    }

    /// Paste the next item from the stack (FIFO - first in, first out)
    func pasteFromStack() {
        guard let item = pasteStack.first else { return }
        pasteStack.removeFirst()
        paste(item: item)
    }

    /// Clear all items from the paste stack
    func clearPasteStack() {
        pasteStack.removeAll()
    }

    private func simulatePaste() {
        let source = CGEventSource(stateID: .hidSystemState)

        let keyDown = CGEvent(keyboardEventSource: source, virtualKey: 0x09, keyDown: true) // V key
        keyDown?.flags = .maskCommand

        let keyUp = CGEvent(keyboardEventSource: source, virtualKey: 0x09, keyDown: false)
        keyUp?.flags = .maskCommand

        keyDown?.post(tap: .cghidEventTap)
        keyUp?.post(tap: .cghidEventTap)
    }

    func delete(item: ClipboardItem) {
        history.removeAll { $0.id == item.id }
        pinnedItems.removeAll { $0.id == item.id }
        saveHistory()
    }

    func clearHistory() {
        history.removeAll()
        saveHistory()
    }

    func pasteItemAt(index: Int) {
        guard index < history.count else { return }
        paste(item: history[index])
    }

    func togglePin(item: ClipboardItem) {
        if pinnedItems.contains(where: { $0.id == item.id }) {
            pinnedItems.removeAll { $0.id == item.id }
        } else {
            pinnedItems.insert(item, at: 0)
        }
        saveHistory()
    }

    /// Copy item to clipboard without triggering paste (Cmd+V)
    func copyWithoutPaste(item: ClipboardItem) {
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()

        switch item.content {
        case .text(let string):
            pasteboard.setString(string, forType: .string)
        case .image(let image):
            if let tiffData = image.tiffRepresentation {
                pasteboard.setData(tiffData, forType: .tiff)
            }
        }

        if SettingsModel.shared.playSounds {
            NSSound(named: .init("Pop"))?.play()
        }

        logger.debug("Copied item to clipboard (no paste)")
    }

    /// Update an item's text content (for edit functionality)
    func updateItemContent(id: UUID, newContent: String) {
        guard !newContent.isEmpty else { return }

        if let index = history.firstIndex(where: { $0.id == id }) {
            var updatedItem = history[index]
            updatedItem = ClipboardItem(
                id: updatedItem.id,
                content: .text(newContent),
                timestamp: updatedItem.timestamp,
                sourceAppBundleID: updatedItem.sourceAppBundleID,
                sourceAppName: updatedItem.sourceAppName,
                pasteCount: updatedItem.pasteCount
            )
            history[index] = updatedItem

            // Also update in pinnedItems if present
            if let pinnedIndex = pinnedItems.firstIndex(where: { $0.id == id }) {
                pinnedItems[pinnedIndex] = updatedItem
            }

            saveHistory()
            logger.debug("Updated content for item \(id)")
        }
    }

    func isPinned(_ item: ClipboardItem) -> Bool {
        pinnedItems.contains { $0.id == item.id }
    }

    /// Reorder pinned items via drag and drop
    func movePinnedItems(from source: IndexSet, to destination: Int) {
        pinnedItems.move(fromOffsets: source, toOffset: destination)
        saveHistory()
    }

    /// Export history to JSON data
    func exportHistory() -> Data? {
        let formatter = ISO8601DateFormatter()
        let pinnedIDs = Set(pinnedItems.map { $0.id })
        let exportItems = history.compactMap { item -> [String: Any]? in
            var dict: [String: Any] = [
                "id": item.id.uuidString,
                "timestamp": formatter.string(from: item.timestamp),
                "pasteCount": item.pasteCount
            ]

            if case .text(let string) = item.content {
                dict["text"] = string
            } else {
                // Skip images in export
                return nil
            }

            if let bundleID = item.sourceAppBundleID {
                dict["sourceAppBundleID"] = bundleID
            }
            if let appName = item.sourceAppName {
                dict["sourceAppName"] = appName
            }

            dict["isPinned"] = pinnedIDs.contains(item.id)

            return dict
        }

        return try? JSONSerialization.data(withJSONObject: exportItems, options: .prettyPrinted)
    }

    /// Static export function for use from Settings (reads from disk)
    nonisolated static func exportHistoryFromDisk() -> Data? {
        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let historyURL = appSupport
            .appendingPathComponent("SaneClip", isDirectory: true)
            .appendingPathComponent("history.json")

        guard FileManager.default.fileExists(atPath: historyURL.path),
              let data = try? Data(contentsOf: historyURL),
              let items = try? JSONDecoder().decode([SavedClipboardItem].self, from: data) else {
            return nil
        }

        let pinnedIDs = Set(UserDefaults.standard.stringArray(forKey: "pinnedItemIDs") ?? [])
        let formatter = ISO8601DateFormatter()

        let exportItems: [[String: Any]] = items.map { item in
            var dict: [String: Any] = [
                "id": item.id.uuidString,
                "timestamp": formatter.string(from: item.timestamp),
                "text": item.text,
                "pasteCount": item.pasteCount,
                "isPinned": pinnedIDs.contains(item.id.uuidString)
            ]
            if let bundleID = item.sourceAppBundleID {
                dict["sourceAppBundleID"] = bundleID
            }
            if let appName = item.sourceAppName {
                dict["sourceAppName"] = appName
            }
            return dict
        }

        return try? JSONSerialization.data(withJSONObject: exportItems, options: .prettyPrinted)
    }

    // MARK: - Persistence

    private var historyFileURL: URL {
        let appSupport = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let appFolder = appSupport.appendingPathComponent("SaneClip", isDirectory: true)
        try? FileManager.default.createDirectory(at: appFolder, withIntermediateDirectories: true)
        return appFolder.appendingPathComponent("history.json")
    }

    private func saveHistory() {
        // Only save text items (images are too large)
        let textItems = history.compactMap { item -> SavedClipboardItem? in
            if case .text(let string) = item.content {
                return SavedClipboardItem(
                    id: item.id,
                    text: string,
                    timestamp: item.timestamp,
                    sourceAppBundleID: item.sourceAppBundleID,
                    sourceAppName: item.sourceAppName,
                    pasteCount: item.pasteCount
                )
            }
            return nil
        }

        do {
            let data = try JSONEncoder().encode(textItems)
            try data.write(to: historyFileURL, options: [.atomic, .completeFileProtection])

            // Save pinned item IDs separately
            let pinnedIDs = pinnedItems.map { $0.id.uuidString }
            UserDefaults.standard.set(pinnedIDs, forKey: "pinnedItemIDs")
        } catch {
            logger.error("Failed to save history: \(error.localizedDescription)")
        }
    }

    private func loadHistory() {
        guard FileManager.default.fileExists(atPath: historyFileURL.path) else { return }

        do {
            let data = try Data(contentsOf: historyFileURL)
            let items = try JSONDecoder().decode([SavedClipboardItem].self, from: data)
            history = items.map {
                ClipboardItem(
                    id: $0.id,
                    content: .text($0.text),
                    timestamp: $0.timestamp,
                    sourceAppBundleID: $0.sourceAppBundleID,
                    sourceAppName: $0.sourceAppName,
                    pasteCount: $0.pasteCount
                )
            }

            // Restore pinned items from saved IDs
            if let pinnedIDs = UserDefaults.standard.stringArray(forKey: "pinnedItemIDs") {
                let pinnedUUIDs = Set(pinnedIDs.compactMap { UUID(uuidString: $0) })
                pinnedItems = history.filter { pinnedUUIDs.contains($0.id) }
            }
        } catch {
            logger.error("Failed to load history: \(error.localizedDescription)")
        }
    }

    // MARK: - Import History

    enum ImportError: Error, LocalizedError {
        case invalidFormat
        case readFailed
        case decodeFailed

        var errorDescription: String? {
            switch self {
            case .invalidFormat: return "Invalid file format"
            case .readFailed: return "Could not read file"
            case .decodeFailed: return "Could not decode history data"
            }
        }
    }

    /// Import history from a JSON file
    /// - Parameters:
    ///   - url: URL to the JSON file
    ///   - merge: If true, merge with existing history; if false, replace entirely
    /// - Returns: Number of items imported
    @discardableResult
    func importHistory(from url: URL, merge: Bool) throws -> Int {
        // Read file
        guard let data = try? Data(contentsOf: url) else {
            throw ImportError.readFailed
        }

        // Try to decode as SavedClipboardItem array
        guard let items = try? JSONDecoder().decode([SavedClipboardItem].self, from: data) else {
            throw ImportError.decodeFailed
        }

        // Convert to ClipboardItems
        let importedItems = items.map { saved in
            ClipboardItem(
                id: saved.id,
                content: .text(saved.text),
                timestamp: saved.timestamp,
                sourceAppBundleID: saved.sourceAppBundleID,
                sourceAppName: saved.sourceAppName,
                pasteCount: saved.pasteCount
            )
        }

        if merge {
            // Skip items with existing IDs
            let existingIDs = Set(history.map { $0.id })
            let newItems = importedItems.filter { !existingIDs.contains($0.id) }
            history.append(contentsOf: newItems)
            // Sort by timestamp, newest first
            history.sort { $0.timestamp > $1.timestamp }
            saveHistory()
            logger.info("Merged \(newItems.count) new items from import")
            return newItems.count
        } else {
            // Replace entire history
            history = importedItems
            pinnedItems = []  // Clear pins since items are new
            saveHistory()
            logger.info("Replaced history with \(importedItems.count) imported items")
            return importedItems.count
        }
    }
}
